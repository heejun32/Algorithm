6-1. 코드 블록 단위의 복잡도 분석

알고리즘 문제의 N이 커졌을 때, 작동을 잘 할 것인지 판단할 때 매우 중요함.

예로 binary search는 세타(logn)의 시간이 걸림.
이는 문제 사이즈 n을 2만큼 늘려도 시간은 1만큼 증가

정해진 연산: 사칙연산들을 의미하며, 이를 instruction이라 하며 이를 모아둔 것을 instruction set이라 한다.
이는 CPU, GPU마다 instruction set이 다르다. 그래서 우리가 프로그램을 컴파일 한다는 의미는, 컴파일 한다음에 머신이 수행할 수 있는
인스트럭션 레벨로 표현한다는 뜻이다.
따라서 컴파일 할 때는 타겟을 정함. 에로 이 프로그램은 arm 프로세스에서 작동할 것이다 등.
이를 x86에서 실행시키면 인스터력션 셋이 달라서 작동하지 않음.

어떤 특정한 인스트럭션은 어떤 특정 CPU에서 정확하게 몇 번의 사이클에 수행되는지 정해져 있음.
예로 덧셈은 5사이클, 곱셉은 10사이클 등

CPU스펙의 1GHz 등은 초당 CPU 연산을 의미함.
그러나 연산을 정확하게 계산하기는 매우 어려움. 메모리에서 cpu로 데이터를 업로드 할때 캐시를 사용.
CPU 연산은 너무 많기 때문

인스터럭션의 예시
Ox0687000000F
프로세서한테 어떤 연산을 해야하며 어떤 데이터들 사이에서 연산을 수행해라 이런 것의 조합임.
Ox0687: 인스터럭션 부분
이를 사람이 알아 볼 수 있게 한 것이 어셈블리 언어다.

하이레벨, 로우레벨 랭귀지의 의미는 좋고 나쁨의 차이가 아닌 사람이 얼마나 이해하기 쉬우냐의 기준이다.
C, C++는 미들레벨 랭귀지다. 메모리를 다룰 수 있기 때문

Operators
    - 연산들은 우리는 다 constant 타임 안에 수행될 수 있다고 가정
    - why? 머신 인스터럭션에 매핑되기 때문임.
    - malloc, free 함수는 연산이 기존 사칙연산보다 매우 느린데, 그 이유는 운영체제와 소통해야 하기 때문
    - 그럼에도 불구하고 single CPU 인스트럭션에 수행가능한 부분이기에 constant(linear) 취급함

Blocks in Sequence
    - 코드 블럭이 시퀀스로 나눠졌을 때
    - 이중 가장 dominant term 복잡도를 대표로 계산한다. Ex. 세타(1) + 세타(n) = 세타(n)


control statement 계산 (if, for문 등)
    - 일반적으로 if 문을 테스트하는 복잡도는 constant 타임으로 생각함
    - why? 간단한 연사들이 주이기 때문, 그러나 function call을 하면 constant하게 끝나지 않음
    - 팩토리얼 함수를 보면, n만큼 반복되는 걸 파악 가능. 그러나 이외에 함수는 이를 파악하기 어려움
    - 따라서 우리가 할 수 있는 두가지는 최악의 경우 이 알고리즘이 몇번 동작하는가? 또는 평균적으로 일반적인 데이터가 주어졌을 때 계산 가능

Condition-controlled Loops(반복문)
    - 반복 횟수는 n만큼 수행 되는 것은 알 수 있음. (최소한 n번 반복, break문 없다고 가정)
    - 만약 어떤 반복문 안에 코드가 있고 이 코드의 복잡도가 세타(n)일 때 최종적으로 세타(nf(n))만큼의 복잡도를 가짐)(최소한 n번 반복, break문 없다고 가정)
    - 그러나 단순연산 함수가 반복문 안에 있을 수도 있기에 이때는 반복문 안에 함수는 constant 타임임.
    - 계산할때 안쪽부터 바깥쪽으로 나가면 됨.

Serial Statements
    - 오름차순 정렬된 데이터에서 최댓값 찾을 때는 항상 전체를 봐야 하기에  세타 오브 n
    - 특정값을 찾을 때, 최악의 경우 모든 데이터를 봐야 되기 때문에 빅오 오브 n
    - 그러므로 빅오, 세타 등이 섞여 있을 때 우리는 leading term 기준으로 나눔.
    - 복잡도가 제일 큰 것으로 계산

Function
    - 반복되는 오퍼레이션을 펑션, 혹은 서브루틴으로 부름.
    - 펑션 콜은 어떤 프로그램으로 점프했다가 복귀하는 형태.
    - 따라서 함수를 수행한다는 것은 함수 구동환경 준비, 파라미터 처리, 서브루틴으로 바이너리 점프한 다음 복귀
    - 최신 프로세스들은 이런 것들을 사실 constant 타임에 해줄 수 있는 인스트럭션 셋이 있음.
    - 따라서 어떤 펑션 콜이던 공짜는 될 수 없음. 심지어 함수 안에서 아무것도 않더라도 이것의 복잡다는 constant라고 취급
    - 따라서 복잡는 오메가 오브 1임. 함수 복잡도는 T(n)으로 부름.


